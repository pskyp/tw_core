// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'tender_timeline.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$TenderTimelineFailuresTearOff {
  const _$TenderTimelineFailuresTearOff();

  SubmissionBeforeQueries submissionBeforeQueries() {
    return const SubmissionBeforeQueries();
  }

  FeedbackBeforeSubmission feedbackBeforeSubmission() {
    return const FeedbackBeforeSubmission();
  }

  AwardBeforeFeedback awardBeforeFeedback() {
    return const AwardBeforeFeedback();
  }
}

/// @nodoc
const $TenderTimelineFailures = _$TenderTimelineFailuresTearOff();

/// @nodoc
mixin _$TenderTimelineFailures {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() submissionBeforeQueries,
    required TResult Function() feedbackBeforeSubmission,
    required TResult Function() awardBeforeFeedback,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? submissionBeforeQueries,
    TResult Function()? feedbackBeforeSubmission,
    TResult Function()? awardBeforeFeedback,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SubmissionBeforeQueries value)
        submissionBeforeQueries,
    required TResult Function(FeedbackBeforeSubmission value)
        feedbackBeforeSubmission,
    required TResult Function(AwardBeforeFeedback value) awardBeforeFeedback,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SubmissionBeforeQueries value)? submissionBeforeQueries,
    TResult Function(FeedbackBeforeSubmission value)? feedbackBeforeSubmission,
    TResult Function(AwardBeforeFeedback value)? awardBeforeFeedback,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TenderTimelineFailuresCopyWith<$Res> {
  factory $TenderTimelineFailuresCopyWith(TenderTimelineFailures value,
          $Res Function(TenderTimelineFailures) then) =
      _$TenderTimelineFailuresCopyWithImpl<$Res>;
}

/// @nodoc
class _$TenderTimelineFailuresCopyWithImpl<$Res>
    implements $TenderTimelineFailuresCopyWith<$Res> {
  _$TenderTimelineFailuresCopyWithImpl(this._value, this._then);

  final TenderTimelineFailures _value;
  // ignore: unused_field
  final $Res Function(TenderTimelineFailures) _then;
}

/// @nodoc
abstract class $SubmissionBeforeQueriesCopyWith<$Res> {
  factory $SubmissionBeforeQueriesCopyWith(SubmissionBeforeQueries value,
          $Res Function(SubmissionBeforeQueries) then) =
      _$SubmissionBeforeQueriesCopyWithImpl<$Res>;
}

/// @nodoc
class _$SubmissionBeforeQueriesCopyWithImpl<$Res>
    extends _$TenderTimelineFailuresCopyWithImpl<$Res>
    implements $SubmissionBeforeQueriesCopyWith<$Res> {
  _$SubmissionBeforeQueriesCopyWithImpl(SubmissionBeforeQueries _value,
      $Res Function(SubmissionBeforeQueries) _then)
      : super(_value, (v) => _then(v as SubmissionBeforeQueries));

  @override
  SubmissionBeforeQueries get _value => super._value as SubmissionBeforeQueries;
}

/// @nodoc

class _$SubmissionBeforeQueries implements SubmissionBeforeQueries {
  const _$SubmissionBeforeQueries();

  @override
  String toString() {
    return 'TenderTimelineFailures.submissionBeforeQueries()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is SubmissionBeforeQueries);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() submissionBeforeQueries,
    required TResult Function() feedbackBeforeSubmission,
    required TResult Function() awardBeforeFeedback,
  }) {
    return submissionBeforeQueries();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? submissionBeforeQueries,
    TResult Function()? feedbackBeforeSubmission,
    TResult Function()? awardBeforeFeedback,
    required TResult orElse(),
  }) {
    if (submissionBeforeQueries != null) {
      return submissionBeforeQueries();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SubmissionBeforeQueries value)
        submissionBeforeQueries,
    required TResult Function(FeedbackBeforeSubmission value)
        feedbackBeforeSubmission,
    required TResult Function(AwardBeforeFeedback value) awardBeforeFeedback,
  }) {
    return submissionBeforeQueries(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SubmissionBeforeQueries value)? submissionBeforeQueries,
    TResult Function(FeedbackBeforeSubmission value)? feedbackBeforeSubmission,
    TResult Function(AwardBeforeFeedback value)? awardBeforeFeedback,
    required TResult orElse(),
  }) {
    if (submissionBeforeQueries != null) {
      return submissionBeforeQueries(this);
    }
    return orElse();
  }
}

abstract class SubmissionBeforeQueries implements TenderTimelineFailures {
  const factory SubmissionBeforeQueries() = _$SubmissionBeforeQueries;
}

/// @nodoc
abstract class $FeedbackBeforeSubmissionCopyWith<$Res> {
  factory $FeedbackBeforeSubmissionCopyWith(FeedbackBeforeSubmission value,
          $Res Function(FeedbackBeforeSubmission) then) =
      _$FeedbackBeforeSubmissionCopyWithImpl<$Res>;
}

/// @nodoc
class _$FeedbackBeforeSubmissionCopyWithImpl<$Res>
    extends _$TenderTimelineFailuresCopyWithImpl<$Res>
    implements $FeedbackBeforeSubmissionCopyWith<$Res> {
  _$FeedbackBeforeSubmissionCopyWithImpl(FeedbackBeforeSubmission _value,
      $Res Function(FeedbackBeforeSubmission) _then)
      : super(_value, (v) => _then(v as FeedbackBeforeSubmission));

  @override
  FeedbackBeforeSubmission get _value =>
      super._value as FeedbackBeforeSubmission;
}

/// @nodoc

class _$FeedbackBeforeSubmission implements FeedbackBeforeSubmission {
  const _$FeedbackBeforeSubmission();

  @override
  String toString() {
    return 'TenderTimelineFailures.feedbackBeforeSubmission()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is FeedbackBeforeSubmission);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() submissionBeforeQueries,
    required TResult Function() feedbackBeforeSubmission,
    required TResult Function() awardBeforeFeedback,
  }) {
    return feedbackBeforeSubmission();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? submissionBeforeQueries,
    TResult Function()? feedbackBeforeSubmission,
    TResult Function()? awardBeforeFeedback,
    required TResult orElse(),
  }) {
    if (feedbackBeforeSubmission != null) {
      return feedbackBeforeSubmission();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SubmissionBeforeQueries value)
        submissionBeforeQueries,
    required TResult Function(FeedbackBeforeSubmission value)
        feedbackBeforeSubmission,
    required TResult Function(AwardBeforeFeedback value) awardBeforeFeedback,
  }) {
    return feedbackBeforeSubmission(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SubmissionBeforeQueries value)? submissionBeforeQueries,
    TResult Function(FeedbackBeforeSubmission value)? feedbackBeforeSubmission,
    TResult Function(AwardBeforeFeedback value)? awardBeforeFeedback,
    required TResult orElse(),
  }) {
    if (feedbackBeforeSubmission != null) {
      return feedbackBeforeSubmission(this);
    }
    return orElse();
  }
}

abstract class FeedbackBeforeSubmission implements TenderTimelineFailures {
  const factory FeedbackBeforeSubmission() = _$FeedbackBeforeSubmission;
}

/// @nodoc
abstract class $AwardBeforeFeedbackCopyWith<$Res> {
  factory $AwardBeforeFeedbackCopyWith(
          AwardBeforeFeedback value, $Res Function(AwardBeforeFeedback) then) =
      _$AwardBeforeFeedbackCopyWithImpl<$Res>;
}

/// @nodoc
class _$AwardBeforeFeedbackCopyWithImpl<$Res>
    extends _$TenderTimelineFailuresCopyWithImpl<$Res>
    implements $AwardBeforeFeedbackCopyWith<$Res> {
  _$AwardBeforeFeedbackCopyWithImpl(
      AwardBeforeFeedback _value, $Res Function(AwardBeforeFeedback) _then)
      : super(_value, (v) => _then(v as AwardBeforeFeedback));

  @override
  AwardBeforeFeedback get _value => super._value as AwardBeforeFeedback;
}

/// @nodoc

class _$AwardBeforeFeedback implements AwardBeforeFeedback {
  const _$AwardBeforeFeedback();

  @override
  String toString() {
    return 'TenderTimelineFailures.awardBeforeFeedback()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is AwardBeforeFeedback);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() submissionBeforeQueries,
    required TResult Function() feedbackBeforeSubmission,
    required TResult Function() awardBeforeFeedback,
  }) {
    return awardBeforeFeedback();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? submissionBeforeQueries,
    TResult Function()? feedbackBeforeSubmission,
    TResult Function()? awardBeforeFeedback,
    required TResult orElse(),
  }) {
    if (awardBeforeFeedback != null) {
      return awardBeforeFeedback();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SubmissionBeforeQueries value)
        submissionBeforeQueries,
    required TResult Function(FeedbackBeforeSubmission value)
        feedbackBeforeSubmission,
    required TResult Function(AwardBeforeFeedback value) awardBeforeFeedback,
  }) {
    return awardBeforeFeedback(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SubmissionBeforeQueries value)? submissionBeforeQueries,
    TResult Function(FeedbackBeforeSubmission value)? feedbackBeforeSubmission,
    TResult Function(AwardBeforeFeedback value)? awardBeforeFeedback,
    required TResult orElse(),
  }) {
    if (awardBeforeFeedback != null) {
      return awardBeforeFeedback(this);
    }
    return orElse();
  }
}

abstract class AwardBeforeFeedback implements TenderTimelineFailures {
  const factory AwardBeforeFeedback() = _$AwardBeforeFeedback;
}
